#!/usr/bin/env python3
"""
DevDoc Documentation Generator

Generates comprehensive, intelligent documentation from analysis data:
- Mermaid architecture diagrams (dependency flows, module relationships)
- Health dashboard with visual indicators
- Trend visualization (if snapshots available)
- Auto-generated API reference from extracted function signatures
- Architecture narrative from reasoner output
- Setup guides pulled from config files

Output: Clean Markdown optimized for WithAI's WYSIWYG editor.

Usage:
    python generate_docs.py --analysis analysis.json [--security security.json]
        [--governance governance.json] [--architecture architecture.json]
        [--git git.json] [--output DOCUMENTATION.md]

Part of the doc-generator WithAI ability.
"""

import json
import sys
import argparse
from pathlib import Path
from datetime import datetime
from typing import Optional


class DocumentationGenerator:
    """Generates intelligent documentation from DevDoc analysis data."""

    def __init__(self, analysis: dict, security: Optional[dict] = None,
                 governance: Optional[dict] = None, architecture: Optional[dict] = None,
                 git: Optional[dict] = None, trends: Optional[dict] = None):
        self.analysis = analysis
        self.security = security or {}
        self.governance = governance or {}
        self.architecture = architecture or {}
        self.git = git or {}
        self.trends = trends or {}

    def generate(self) -> str:
        """Generate the full documentation as markdown."""
        sections = [
            self._header(),
            self._health_dashboard(),
            self._architecture_section(),
            self._dependency_diagram(),
            self._module_breakdown(),
            self._api_reference(),
            self._security_section(),
            self._ai_governance_section(),
            self._trends_section(),
            self._setup_guide(),
            self._dependencies_section(),
            self._footer(),
        ]

        return '\n\n'.join(section for section in sections if section)

    # â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _header(self) -> str:
        name = self.analysis.get('project_name', 'Project')
        summary = self.analysis.get('summary', {})
        tech = self.analysis.get('tech_stack', {})

        languages = ', '.join(tech.get('languages', ['Unknown']))
        frameworks = ', '.join(tech.get('frameworks', [])) or 'None detected'
        tools = ', '.join(tech.get('tools', []))

        return f"""# {name} â€” Documentation

> Auto-generated by **DevDoc Intelligence Platform** â€” AI-powered codebase governance
> Generated: {datetime.now().strftime('%B %d, %Y at %H:%M')}

---

## Overview

| Metric | Value |
|--------|-------|
| **Languages** | {languages} |
| **Frameworks** | {frameworks} |
| **Tools** | {tools} |
| **Source Files** | {summary.get('total_files', 0)} |
| **Lines of Code** | {summary.get('total_code_lines', 0):,} |
| **Functions** | {summary.get('total_functions', 0)} |
| **Classes** | {summary.get('total_classes', 0)} |
| **Has Tests** | {'Yes' if summary.get('has_tests') else 'No'} |
| **Has CI** | {'Yes' if summary.get('has_ci') else 'No'} |"""

    # â”€â”€â”€ Health Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _health_dashboard(self) -> str:
        metrics = self.analysis.get('project_metrics', {})
        sec_score = self.security.get('security_score', 'N/A')
        sec_grade = self.security.get('security_grade', '-')
        gov_score = self.governance.get('governance_score', 'N/A')
        gov_grade = self.governance.get('governance_grade', '-')
        arch_score = self.architecture.get('architecture_score', 'N/A')
        arch_grade = self.architecture.get('architecture_grade', '-')

        doc_cov = metrics.get('docstring_coverage', 0)
        type_cov = metrics.get('type_hint_coverage', 0)
        avg_cx = metrics.get('avg_complexity', 0)

        # Emoji indicators
        def indicator(score, good_threshold=80, warn_threshold=60):
            if isinstance(score, str):
                return 'â¬œ'
            if score >= good_threshold:
                return 'ðŸŸ¢'
            if score >= warn_threshold:
                return 'ðŸŸ¡'
            return 'ðŸ”´'

        return f"""## Health Dashboard

| Dimension | Score | Grade | Status |
|-----------|-------|-------|--------|
| **Architecture** | {arch_score}/100 | {arch_grade} | {indicator(arch_score)} |
| **Security** | {sec_score}/100 | {sec_grade} | {indicator(sec_score)} |
| **AI Governance** | {gov_score}/100 | {gov_grade} | {indicator(gov_score)} |
| **Documentation Coverage** | {doc_cov:.0%} | â€” | {indicator(doc_cov * 100)} |
| **Type Hint Coverage** | {type_cov:.0%} | â€” | {indicator(type_cov * 100, 50, 30)} |
| **Avg Complexity** | {avg_cx:.1f} | â€” | {indicator(100 - avg_cx * 10)} |

### Complexity Distribution

| Range | Count |
|-------|-------|
| Low (1-5) | {metrics.get('complexity_distribution', {}).get('low (1-5)', 0)} |
| Medium (6-10) | {metrics.get('complexity_distribution', {}).get('medium (6-10)', 0)} |
| High (11-15) | {metrics.get('complexity_distribution', {}).get('high (11-15)', 0)} |
| Critical (>15) | {metrics.get('complexity_distribution', {}).get('critical (>15)', 0)} |"""

    # â”€â”€â”€ Architecture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _architecture_section(self) -> str:
        if not self.architecture:
            return ''

        pattern = self.architecture.get('architecture_pattern', {})
        narrative = self.architecture.get('summary', '')
        recs = self.architecture.get('strategic_recommendations', [])

        # Tree
        tree = self.analysis.get('directory_tree', '')

        sections = [f"""## Architecture

### Detected Pattern

**{pattern.get('detected_pattern', 'Unknown')}** (confidence: {pattern.get('confidence', 0):.0%})

### Directory Structure

```
{tree}
```"""]

        # Narrative from reasoner
        if narrative:
            sections.append(narrative)

        # Strategic recommendations
        if recs:
            sections.append("\n### Strategic Recommendations\n")
            sections.append("| Priority | Category | Target | Action | Effort |")
            sections.append("|----------|----------|--------|--------|--------|")
            for r in recs:
                sections.append(
                    f"| P{r.get('priority', '-')} | {r.get('category', '')} | "
                    f"`{r.get('target', '')}` | {r.get('action', '')[:80]} | {r.get('effort', '-')} |"
                )

        return '\n'.join(sections)

    # â”€â”€â”€ Dependency Diagram â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _dependency_diagram(self) -> str:
        dep_graph = self.analysis.get('dependency_graph', {})
        edges = dep_graph.get('edges', {})

        if not edges:
            return ''

        # Build Mermaid flowchart
        mermaid_lines = ['```mermaid', 'flowchart TD']

        # Create node IDs from filenames
        node_ids = {}
        for fp in set(list(edges.keys()) + [t for targets in edges.values() for t in targets]):
            node_id = Path(fp).stem.replace('-', '_').replace('.', '_')
            node_ids[fp] = node_id
            # Style based on fan-in
            fan_in = dep_graph.get('fan_metrics', {}).get(fp, {}).get('fan_in', 0)
            if fan_in >= 3:
                mermaid_lines.append(f'    {node_id}["{Path(fp).stem}\\n(fan-in: {fan_in})"]')
            else:
                mermaid_lines.append(f'    {node_id}["{Path(fp).stem}"]')

        # Add edges
        for source, targets in edges.items():
            src_id = node_ids.get(source, source)
            for target in targets:
                tgt_id = node_ids.get(target, target)
                mermaid_lines.append(f'    {src_id} --> {tgt_id}')

        # Style high fan-in nodes
        for fp, metrics in dep_graph.get('fan_metrics', {}).items():
            if metrics.get('fan_in', 0) >= 3 and fp in node_ids:
                mermaid_lines.append(f'    style {node_ids[fp]} fill:#ff9800,stroke:#e65100')

        mermaid_lines.append('```')

        return f"""### Dependency Graph

{chr(10).join(mermaid_lines)}

> Orange nodes have high fan-in (3+ modules depend on them) â€” changes carry higher risk."""

    # â”€â”€â”€ Module Breakdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _module_breakdown(self) -> str:
        file_analyses = self.analysis.get('file_analyses', [])
        if not file_analyses:
            return ''

        sections = ["## Module Breakdown\n"]
        sections.append("| Module | Lines | Functions | Classes | Avg Complexity | Docstring Coverage | Type Hints |")
        sections.append("|--------|-------|-----------|---------|---------------|--------------------|------------|")

        for fa in sorted(file_analyses, key=lambda f: f.get('total_lines', 0), reverse=True):
            if 'error' in fa:
                continue
            fp = fa['filepath']
            sections.append(
                f"| `{fp}` | {fa.get('total_lines', 0)} | {fa.get('function_count', 0)} | "
                f"{fa.get('class_count', 0)} | {fa.get('avg_complexity', 0):.1f} | "
                f"{fa.get('type_hint_coverage', 0):.0%} | "
                f"{'Yes' if fa.get('has_module_docstring') else 'No'} |"
            )

        return '\n'.join(sections)

    # â”€â”€â”€ API Reference â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _api_reference(self) -> str:
        file_analyses = self.analysis.get('file_analyses', [])

        sections = ["## API Reference\n"]

        for fa in file_analyses:
            if 'error' in fa:
                continue

            classes = fa.get('classes', [])
            functions = fa.get('functions', [])

            if not classes and not functions:
                continue

            sections.append(f"### `{fa['filepath']}`\n")

            if fa.get('has_module_docstring'):
                # We don't have the full docstring, just note it exists
                pass

            for cls in classes:
                bases = f"({', '.join(cls['bases'])})" if cls.get('bases') else ""
                sections.append(f"#### Class `{cls['name']}{bases}`")
                if cls.get('docstring_summary'):
                    sections.append(f"> {cls['docstring_summary']}")
                sections.append(f"- Lines: {cls['line']}-{cls.get('end_line', '?')}")
                sections.append(f"- Methods: {', '.join(cls.get('methods', []))}")
                if cls.get('class_variables'):
                    sections.append(f"- Variables: {', '.join(cls['class_variables'])}")
                sections.append("")

            # Public functions only (not methods, not private)
            public_funcs = [f for f in functions if not f.get('is_method') and not f['name'].startswith('_')]
            if public_funcs:
                sections.append("#### Functions\n")
                sections.append("| Function | Complexity | Params | Docs | Line |")
                sections.append("|----------|-----------|--------|------|------|")
                for func in public_funcs:
                    doc_icon = 'âœ…' if func['has_docstring'] else 'âŒ'
                    sections.append(
                        f"| `{func.get('signature', func['name'])}` | "
                        f"{func['complexity']} | {func['param_count']} | "
                        f"{doc_icon} | {func['line']} |"
                    )
                sections.append("")

        return '\n'.join(sections)

    # â”€â”€â”€ Security â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _security_section(self) -> str:
        if not self.security or not self.security.get('findings'):
            return """## Security Scan

ðŸŸ¢ **No security issues detected.** Clean scan across all files."""

        findings = self.security['findings']
        severity = self.security.get('severity_counts', {})

        sections = [f"""## Security Scan

**Score:** {self.security.get('security_score', '?')}/100 (Grade: {self.security.get('security_grade', '?')})

| Severity | Count |
|----------|-------|
| Critical | {severity.get('CRITICAL', 0)} |
| High | {severity.get('HIGH', 0)} |
| Medium | {severity.get('MEDIUM', 0)} |
| Low | {severity.get('LOW', 0)} |

### Findings
"""]

        for f in findings[:15]:
            sections.append(
                f"- **[{f['severity']}]** `{f['file']}:{f['line']}` â€” {f['description']}"
            )
            if f.get('code'):
                sections.append(f"  ```\n  {f['code']}\n  ```")

        return '\n'.join(sections)

    # â”€â”€â”€ AI Governance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _ai_governance_section(self) -> str:
        if not self.governance:
            return ''

        findings = self.governance.get('findings', [])
        recs = self.governance.get('recommendations', [])

        sections = [f"""## AI Code Governance

**Score:** {self.governance.get('governance_score', '?')}/100 (Grade: {self.governance.get('governance_grade', '?')})
**Summary:** {self.governance.get('summary', 'No data')}

### Issue Types

| Type | Count |
|------|-------|"""]

        for t, count in self.governance.get('type_counts', {}).items():
            sections.append(f"| {t.replace('_', ' ').title()} | {count} |")

        if findings:
            sections.append("\n### Findings\n")
            for f in findings[:10]:
                sections.append(f"- **[{f['severity']}]** {f['message']}")
                if f.get('details', {}).get('suggestion'):
                    sections.append(f"  > ðŸ’¡ {f['details']['suggestion']}")

        if recs:
            sections.append("\n### Recommendations\n")
            for r in recs:
                sections.append(f"- {r}")

        return '\n'.join(sections)

    # â”€â”€â”€ Trends â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _trends_section(self) -> str:
        if not self.trends or not self.trends.get('data_points'):
            return """## Trends

> No historical snapshots available yet. Run DevDoc multiple times to build trend data.
> Snapshots are stored in `.devdoc/snapshots/`."""

        data = self.trends
        trend_data = data.get('trends', {})

        sections = [f"""## Health Trends

**Period:** {data.get('time_range', {}).get('oldest', '?')[:10]} to {data.get('time_range', {}).get('newest', '?')[:10]}
**Snapshots:** {data.get('snapshot_count', 0)} data points

### Metric Trends

| Metric | Start | Current | Change | Direction |
|--------|-------|---------|--------|-----------|"""]

        for metric, info in trend_data.items():
            direction_icon = {
                'increasing': 'ðŸ“ˆ',
                'decreasing': 'ðŸ“‰',
                'stable': 'âž¡ï¸',
            }.get(info.get('direction', ''), '?')

            # For complexity, increasing is bad
            if 'complexity' in metric and info.get('direction') == 'increasing':
                direction_icon = 'ðŸ”´ ðŸ“ˆ'
            elif 'coverage' in metric and info.get('direction') == 'decreasing':
                direction_icon = 'ðŸ”´ ðŸ“‰'

            sections.append(
                f"| {metric.replace('_', ' ').title()} | {info.get('start', 0)} | "
                f"{info.get('end', 0)} | {info.get('change_pct', 0):+.1f}% | {direction_icon} |"
            )

        # Mermaid trend chart
        points = data.get('data_points', [])
        if len(points) >= 2:
            sections.append("\n### Complexity Trend\n")
            sections.append("```mermaid")
            sections.append("xychart-beta")
            sections.append('    title "Average Complexity Over Time"')

            labels = [f'"{p.get("label", p.get("timestamp", "")[:10])}"' for p in points]
            values = [str(p.get('avg_complexity', 0)) for p in points]

            sections.append(f"    x-axis [{', '.join(labels)}]")
            sections.append(f'    y-axis "Complexity"')
            sections.append(f"    line [{', '.join(values)}]")
            sections.append("```")

        return '\n'.join(sections)

    # â”€â”€â”€ Setup Guide â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _setup_guide(self) -> str:
        config_contents = self.analysis.get('config_contents', {})
        entry_points = self.analysis.get('entry_points', [])

        sections = ["## Getting Started\n"]

        # Entry points
        if entry_points:
            sections.append(f"**Entry Point(s):** {', '.join(f'`{e}`' for e in entry_points)}\n")

        # From README
        readme = config_contents.get('README.md', '')
        if readme:
            # Extract setup sections if they exist
            in_setup = False
            setup_lines = []
            for line in readme.split('\n'):
                lower = line.lower().strip()
                if any(kw in lower for kw in ['## quick start', '## setup', '## installation', '## getting started']):
                    in_setup = True
                    continue
                elif line.startswith('## ') and in_setup:
                    in_setup = False
                elif in_setup:
                    setup_lines.append(line)

            if setup_lines:
                sections.append("### Setup Instructions\n")
                sections.extend(setup_lines[:20])
                sections.append("")

        # Dependencies
        deps = self.analysis.get('dependencies', {})
        if deps:
            sections.append("### Install Dependencies\n")
            if 'python' in deps:
                sections.append("```bash")
                sections.append("pip install -r requirements.txt")
                sections.append("```")
            if 'production' in deps:
                sections.append("```bash")
                sections.append("npm install")
                sections.append("```")

        return '\n'.join(sections)

    # â”€â”€â”€ Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _dependencies_section(self) -> str:
        deps = self.analysis.get('dependencies', {})
        if not deps:
            return ''

        sections = ["## Dependencies\n"]

        for category, pkg_list in deps.items():
            sections.append(f"### {category.title()}\n")
            sections.append("| Package | Version |")
            sections.append("|---------|---------|")
            for pkg in pkg_list:
                if '==' in pkg:
                    name, ver = pkg.split('==', 1)
                elif '@' in pkg:
                    name, ver = pkg.split('@', 1)
                else:
                    name = pkg
                    ver = '*'
                sections.append(f"| {name} | {ver} |")
            sections.append("")

        return '\n'.join(sections)

    # â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _footer(self) -> str:
        return """---

*Generated by **DevDoc Intelligence Platform** â€” Continuous codebase governance for AI-assisted development.*
*Open this file in WithAI's WYSIWYG editor for visual editing, or export to PDF using the generate-pdf-from-md skill.*"""


# â”€â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    parser = argparse.ArgumentParser(description='DevDoc Documentation Generator')
    parser.add_argument('--analysis', '-a', required=True, help='Path to analysis.json')
    parser.add_argument('--security', '-s', help='Path to security.json')
    parser.add_argument('--governance', '-g', help='Path to governance.json')
    parser.add_argument('--architecture', '-r', help='Path to architecture.json')
    parser.add_argument('--git', help='Path to git.json')
    parser.add_argument('--trends', '-t', help='Path to trends.json')
    parser.add_argument('--output', '-o', help='Output markdown file path')
    args = parser.parse_args()

    # Load all available data
    def load_json(path):
        if path and Path(path).exists():
            with open(path) as f:
                return json.load(f)
        return None

    analysis = load_json(args.analysis) or {}
    security = load_json(args.security)
    governance = load_json(args.governance)
    architecture = load_json(args.architecture)
    git = load_json(args.git)
    trends = load_json(args.trends)

    generator = DocumentationGenerator(
        analysis, security, governance, architecture, git, trends
    )
    markdown = generator.generate()

    if args.output:
        Path(args.output).parent.mkdir(parents=True, exist_ok=True)
        with open(args.output, 'w') as f:
            f.write(markdown)
        print(f"Documentation saved to: {args.output}", file=sys.stderr)
    else:
        print(markdown)


if __name__ == '__main__':
    main()
